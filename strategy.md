# Polymarket Whale Copy Bot — 전략 설명서

> 작성일: 2026-02-28
> 모드: Paper Trading (실전 준비 단계)
> 초기 자본: $5,000 USDC

---

## 목차

1. [전략 개요](#1-전략-개요)
2. [Polymarket이란?](#2-polymarket이란)
3. [왜 고래를 따라가는가?](#3-왜-고래를-따라가는가)
4. [시스템 구조](#4-시스템-구조)
5. [Phase 1 — 고래 발굴 (Whale Manager)](#5-phase-1--고래-발굴-whale-manager)
6. [Phase 2 — 실시간 감시 (Signal Detection)](#6-phase-2--실시간-감시-signal-detection)
7. [Phase 3 — 진입 필터 (Entry Filters)](#7-phase-3--진입-필터-entry-filters)
8. [Phase 4 — 베팅 규모 산출 (Kelly Criterion)](#8-phase-4--베팅-규모-산출-kelly-criterion)
9. [Phase 5 — 체결 (Execution)](#9-phase-5--체결-execution)
10. [Phase 6 — 포지션 관리 및 청산 (Position Management)](#10-phase-6--포지션-관리-및-청산-position-management)
11. [비용 구조 (현실화 파라미터)](#11-비용-구조-현실화-파라미터)
12. [안전장치 총람](#12-안전장치-총람)
13. [수익 시나리오](#13-수익-시나리오)
14. [현재 한계 및 리스크](#14-현재-한계-및-리스크)

---

## 1. 전략 개요

```
핵심 아이디어:
"Polymarket에서 일관되게 수익을 내는 고래(대형 베터)를 식별하고,
 그들이 새 포지션을 취하는 순간 동일 방향으로 자동 복사한다."
```

이 봇은 **Whale Copy Trading** 전략을 구현한다.
직접 시장을 예측하지 않고, 이미 예측에 성공한 검증된 플레이어의 행동을 복사(mirroring)하여 수익을 추구한다.

---

## 2. Polymarket이란?

Polymarket은 블록체인(Polygon) 기반의 **예측 시장(Prediction Market)** 플랫폼이다.

### 기본 작동 원리

```
질문 예시: "Bitcoin이 2월 28일 오후 2시~2시 5분 ET 동안 오를 것인가?"

참가자들은 YES 또는 NO 토큰을 $0~$1 사이에서 거래한다.
- YES 토큰 현재가 $0.30 = 시장이 30% 확률로 YES를 예측한다는 의미
- 마켓 종료 시 정답 토큰 = $1.00, 오답 토큰 = $0.00 으로 정산
```

### 주요 마켓 유형 (봇 대상)

| 유형 | 설명 | 예시 |
|------|------|------|
| 5분 UP/DOWN | BTC/ETH/SOL/XRP 5분 가격 방향 | Bitcoin Up or Down - Feb 28, 2:00PM-2:05PM ET |
| 15분 UP/DOWN | 동일, 15분 단위 | Ethereum Up or Down - Feb 28, 2:00PM-2:15PM ET |

이런 반복적(Recurring) 마켓에 집중하는 이유:
- **결과가 빠르다** (5~15분 내 정산)
- **유동성이 높다** (대형 베터들이 자주 참여)
- **고래 추적이 쉽다** (반복 패턴이 있어 실력 검증 가능)

---

## 3. 왜 고래를 따라가는가?

### 예측 시장의 정보 비대칭

일반 참가자는 BTC가 오를지 내릴지 예측하기 어렵다.
하지만 **일부 참가자는 일관되게 높은 승률을 보인다.** 이들은:

1. **더 빠른 데이터 접근** — 전문 트레이딩 인프라로 실시간 가격 데이터 분석
2. **ML/알고리즘 모델** — 단기 가격 방향 예측 모델을 보유할 가능성
3. **시장 구조 이해** — 유동성 패턴, 호가창 구조를 읽는 능력

이들의 거래를 복사하면 **그들의 알파를 간접적으로 차용**할 수 있다.

### Copy Trading의 수익 원리

```
고래 진입가: $0.30 (YES 토큰)
우리 진입가: $0.315 (슬리피지 5% 적용)
마켓 결과: YES 정답 → 정산가 $1.00

수익 = ($1.00 × shares) - $200 투자금
     ≈ ($1.00 / $0.315) × $200 × 0.98 - $200
     ≈ $622 - $200 = +$422  (211% 수익)
```

단, 고래보다 **늦게 진입**하므로 가격이 이미 움직인 후에 들어가는 불리함이 있다.
이를 슬리피지(slippage)로 모델링하여 현실적인 체결가를 계산한다.

---

## 4. 시스템 구조

```
┌─────────────────────────────────────────────────────────┐
│                    whale_copy_bot.py                     │
│                                                         │
│  ┌──────────────┐    ┌──────────────┐    ┌───────────┐ │
│  │ _maintenance │    │  run_loop()  │    │ _pending  │ │
│  │    _loop()   │    │  (3초 주기)  │    │ _order_   │ │
│  │  (백그라운드) │    │  메인 루프   │    │  loop()   │ │
│  └──────┬───────┘    └──────┬───────┘    └─────┬─────┘ │
│         │                  │                   │       │
│         ▼                  ▼                   ▼       │
│  [whale_manager]   [_check_whale_activity]  [지정가큐] │
│  [whale_scorer ]   [_settle_positions   ]              │
│                    [_update_dashboard   ]              │
└─────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────┐     ┌──────────────────┐
│  whales.json    │     │ trade_history.   │
│ (고래 DB)       │     │ jsonl (거래 로그) │
└─────────────────┘     └──────────────────┘
         │
         ▼
┌─────────────────┐
│  dashboard.py   │
│ (실시간 모니터링) │
└─────────────────┘
```

### 비동기 병렬 처리

```python
# 30마리 고래를 동시에 조회 (순차 X, 병렬 O)
tasks = [_check_whale_activity(addr) for addr in whales]
await asyncio.gather(*tasks)
```

3초마다 모든 활성 고래의 최신 거래를 동시에 조회하여 **감지 지연을 최소화**한다.

---

## 5. Phase 1 — 고래 발굴 (Whale Manager)

### 실행 주기
- **최초 실행 시**: 즉시 실행 (리더보드 상위 500명 평가)
- **이후**: 4시간마다 자동 재실행

### 발굴 프로세스

```
Step 1: Polymarket 리더보드 API에서 상위 500명 조회
        GET https://data-api.polymarket.com/leaderboard

Step 2: 각 후보의 최근 거래 이력 분석
        GET https://data-api.polymarket.com/activity?user={addr}

Step 3: 성과 지표 계산
        - ROI (수익률) = 총 수익 / 총 투자금
        - Win Rate (승률) = 승리 건수 / 전체 건수

Step 4: 기준 통과 여부 판단
        ✅ 통과: ROI > 50% AND 승률 > 60%
        ❌ 탈락: 기준 미달

Step 5: 통과 고래 → whales.json에 status: "active"로 등록
```

### 유지 관리

```
기존 고래 재평가:
  - 48시간 내 활동 없음 → inactive 전환 (비활성 고래 자동 퇴출)
  - 성과 기준 미달로 떨어진 고래 → inactive 전환

결과: 항상 "현재 활발히 수익을 내는" 고래만 추적
```

---

## 6. Phase 2 — 실시간 감시 (Signal Detection)

### 폴링 주기: 3초

```python
# 매 3초마다 반복
while True:
    await check_all_whales()   # 고래 거래 감지
    await settle_positions()   # 보유 포지션 정산 확인
    update_dashboard()         # 대시보드 갱신
    await sleep(3)
```

### 거래 감지 API

```
GET https://data-api.polymarket.com/activity?user={whale_address}&limit=25

응답 필드:
  - type: "TRADE"
  - side: "BUY" or "SELL"
  - transactionHash: 고유 트랜잭션 ID (중복 감지용)
  - price: 고래의 체결가 (0~1)
  - size: 체결 규모 (USDC)
  - title: 마켓명 ("Bitcoin Up or Down - February 28, 2:00PM-2:05PM ET")
  - outcome: 고래가 선택한 방향 ("Up" or "Down")
  - conditionId: 마켓 고유 ID
  - slug: 이벤트 슬러그 (Gamma API 조회용)
  - timestamp: 거래 발생 시각
```

### 중복 방지: seen_txs

```python
# 한 번 처리한 트랜잭션은 다시 처리하지 않음
if tx_id not in self.seen_txs:
    self.seen_txs.add(tx_id)
    # 처리 로직...
```

메모리 한계: 10,000건 초과 시 절반 삭제 (순환 버퍼 방식)

---

## 7. Phase 3 — 진입 필터 (Entry Filters)

감지된 고래의 거래가 실제로 복사할 가치가 있는지 6단계 필터를 거친다.

### Filter 1: 백로그 방지 (Startup Time Filter)

```
봇 시작 이전에 발생한 거래는 절대 복사하지 않는다.

이유: 봇을 켰을 때 과거 30분치 거래가 한꺼번에 들어옴
     이미 정산된 마켓에서 "신호"를 잡아 손실 발생 위험
```

### Filter 2: 시간 창 필터 (30분 이내)

```
고래 거래 발생으로부터 30분 이내 거래만 처리

이유: 30분이 지난 신호는 이미 시장이 많이 움직여 진입 의미가 없음
```

### Filter 3: 날짜 필터 ⭐ (핵심 필터)

```python
# 마켓 제목에서 날짜 직접 파싱
"Bitcoin Up or Down - February 27, 7:05PM-7:10PM ET"
                      ↑
                  오늘(2/28)이 아닌 어제(2/27) → 즉시 SKIP

# 오늘 날짜 마켓만 복사 가능
if market_date < today: SKIP
```

**이 필터가 없으면 생기는 문제 (정산 아비트라지)**:
일부 고래는 이미 결과가 확정된 어제 마켓의 "당첨 토큰"을 헐값에 사서 정산받는 전략을 쓴다.
우리가 그걸 복사하면 엄청난 단기 수익처럼 보이지만, 실제로는 재현 불가능한 허수 수익이다.

### Filter 4: 정산 직전 마켓 필터

```
고래 체결가 >= 0.95 → SKIP

이유: 이미 결과가 거의 확정된 마켓(95% 확률)은
     호가창이 비어있어 실제 매수 불가능
     복사해도 체결이 안 됨
```

### Filter 5: Gamma API 마켓 상태 확인

```
slug → Gamma API → 이벤트 데이터 조회

확인 사항:
  1. conditionId가 현재 이벤트 markets 배열에 있는가?
     없으면 → 만료된 Recurring 마켓의 과거 슬롯 → SKIP (Fail Closed)

  2. 마켓 closed = True인가? → SKIP

  3. 마켓 endDate가 현재시각 이전인가? → SKIP

  4. 이벤트 지속기간 365일 초과 (장기 마켓) + 고래 점수 90점 미만 → SKIP
     (기회비용 필터: 자금이 너무 오래 묶이는 장기 베팅 회피)
```

### Filter 6: 동시 포지션 상한

```
현재 보유 포지션 >= 10개 → SKIP

이유: 자본을 너무 분산하면 관리가 어렵고 개별 수익이 미미해짐
```

---

## 8. Phase 4 — 베팅 규모 산출 (Kelly Criterion)

6단계 필터를 통과하면 얼마나 베팅할지 계산한다.

### Kelly Criterion이란?

```
수학적으로 최적의 베팅 비율을 계산하는 공식.
과도한 베팅(파산 위험)과 과소 베팅(수익 기회 낭비) 사이의 균형점.

공식:
  f* = p - (1-p)/b

  p = 승률 (고래 점수 / 100)
  b = 배당비율 = (1 - 진입가) / 진입가
```

### 실제 적용 로직

```
Step 1: 슬리피지를 반영한 목표 진입가 계산
  - 고래 거래 규모별 동적 슬리피지:
    · 규모 $100+  → 5% 슬리피지
    · 규모 $1,000+ → 8% 슬리피지
    · 규모 $5,000+ → 10% 슬리피지
  - VIP 고래 (점수 90+) → 최소 15% 슬리피지 보장

  target_price = whale_price × (1 + slippage%)

Step 2: Kelly 분수 계산
  b = (1 - target_price) / target_price
  kelly_f = p - (1-p) / b

Step 3: Half Kelly 적용 (보수적 운용)
  bet_fraction = kelly_f × 0.5   ← 계산값의 절반만 사용

Step 4: 최대 베팅 캡 적용
  bet_size = min(bankroll × bet_fraction, $200)

  ※ $200 캡의 이유: Kelly 복리 적용 시 뱅크롤이 커지면
    베팅도 기하급수적으로 증가 → 현실에서는 불가능한 리스크
    실전에서는 건당 최대 $200 한도가 현실적

Step 5: EV 음수면 정찰 베팅
  Kelly < 0 → bet_size = min(bankroll × 1.5%, $50)
  (EV가 낮아도 추적은 계속하여 고래 동향 파악)
```

---

## 9. Phase 5 — 체결 (Execution)

### VWAP 기반 체결

```
실제 Polymarket CLOB(중앙 지정가 오더북)에서
우리가 투자할 금액($200)으로 시장가 매수했을 때의
가중평균 체결가(VWAP)를 사전 시뮬레이션한다.

GET https://clob.polymarket.com/book?token_id={market_id}

호가창 asks를 가격 오름차순으로 소화하여:
  $200을 다 쓸 때까지 체결 시뮬레이션
  → 예상 VWAP 산출
```

### 체결 조건

```
VWAP ≤ target_price → 즉시 체결 (FAST EXECUTE)
VWAP > target_price → 대기열(pending) 등록 (10분간 가격 재시도)
VWAP = None (호가창 비어있음) → Gamma API 현재가로 fallback 시도
  - Gamma 조회 실패 → SKIP (Fail Closed)
  - 고래가 대비 20% 이상 괴리 → SKIP (이미 시장 이동)
```

### 거래 수수료 반영

```python
trade_fee = bet_size × 1%      # 1% 거래 수수료 (spread 실비)
shares = (bet_size - trade_fee) / executed_price
# 실제 확보 주식 수는 수수료 차감 후 기준
```

---

## 10. Phase 6 — 포지션 관리 및 청산 (Position Management)

포지션을 보유한 후 3초마다 Gamma API로 현재가를 조회하고 4가지 규칙으로 청산한다.

### 청산 규칙 우선순위

```
1순위: 마켓 자연 정산 (가장 이상적인 시나리오)
       결과 확정 시 winner 필드 확인
       → WIN: 보유 shares × $0.98 수령 (2% 정산수수료 차감)
       → LOSS: $0 수령 (전액 손실)

2순위: Take Profit +30%
       현재 포지션 ROI >= +30%
       → 즉시 매도 (슬리피지 2% 적용 매도가)

3순위: Trailing Stop
       최고점 대비 ROI >= +10% 달성 후 고점 대비 -15% 하락
       → 수익 보호를 위한 동적 손절
       예: 최고 +25% 도달 → +10% 이하로 내려오면 청산

4순위: Stop Loss -30%
       현재 포지션 ROI <= -30%
       → 손실 제한 (더 큰 손실 방지)

5순위: 타임아웃 (3일)
       포지션 보유 3일 초과
       → 강제 청산 (기회비용 제거)
```

### 매도 시 비용

```python
effective_sell_price = current_price × (1 - 2%)  # 2% 매도 슬리피지
payout = shares × effective_sell_price
profit = payout - invested_amount
```

### 고래 미러 청산

```
고래가 보유 중인 마켓을 SELL하면 → 우리도 즉시 SELL
(고래의 EXIT 신호를 추적하는 Mirror Exit 로직)
```

### 재진입 쿨다운

```
청산 후 동일 마켓 재진입 10분 금지

이유: 청산 직후 같은 포지션을 반복 진입하면
     동일한 리스크에 반복 노출되는 "무한루프" 방지
```

---

## 11. 비용 구조 (현실화 파라미터)

실제 Polymarket 거래에서 발생하는 비용을 모두 반영한다.

| 비용 항목 | 비율 | 설명 |
|---------|------|------|
| 거래 수수료 | 1% | 매수 시 spread 실비 |
| 매수 슬리피지 | 3%~15% | 고래 발견 후 진입 지연 동안 가격 이동 |
| 매도 슬리피지 | 2% | 호가창 불리한 가격으로 체결 |
| 정산 수수료 | 2% | Polymarket 프로토콜 수수료 (정답 정산 시) |
| **총 왕복 비용** | **~8~20%** | 진입부터 청산까지 전체 비용 |

---

## 12. 안전장치 총람

| 안전장치 | 목적 |
|---------|------|
| `startup_time` 백로그 필터 | 봇 시작 전 거래 소급 방지 |
| 날짜 직접 파싱 필터 | 어제 마켓 정산 아비트라지 완전 차단 |
| `price >= 0.95` 필터 | 정산 직전 마켓 진입 방지 |
| Gamma API Fail Closed | conditionId 불일치 시 무조건 SKIP |
| VWAP 시뮬레이션 | 실제 체결 가능한 가격만 진입 |
| Fallback 20% 괴리 필터 | 고래 진입가와 현재가 크게 다를 때 SKIP |
| `MAX_BET_SIZE = $200` | Kelly 복리 폭주 방지 |
| `MAX_POSITIONS = 10` | 동시 포지션 상한 |
| 재진입 쿨다운 10분 | 동일 마켓 무한루프 방지 |
| Trailing Stop | 수익 보호 (고점 대비 -15%) |
| Hard Stop Loss -30% | 대형 손실 방지 |
| 3일 타임아웃 | 장기 부진 포지션 강제 청산 |
| `seen_txs` 중복 방지 | 동일 거래 반복 처리 방지 |

---

## 13. 수익 시나리오

### 단일 거래 예시 (이상적인 케이스)

```
고래 BTC UP 매수, 가격 $0.30

우리 진입:
  슬리피지 5% → 목표가 $0.315
  VWAP 시뮬레이션 → $0.312 (목표가 이하) → 체결
  투자금 $200, 수수료 1% → 실제 투자 $198
  확보 shares = $198 / $0.312 = 634.6 shares

케이스 A: BTC 상승 → YES 정산 $1.00
  수령 = 634.6 × $0.98 = $621.9
  수익 = $621.9 - $200 = +$421.9 (+211%)

케이스 B: Take Profit ROI +30% 달성 (현재가 $0.405)
  매도가 = $0.405 × 0.98 = $0.397
  수령 = 634.6 × $0.397 = $251.9
  수익 = $251.9 - $200 = +$51.9 (+26%)

케이스 C: Stop Loss ROI -30% (현재가 $0.219)
  매도가 = $0.219 × 0.98 = $0.215
  수령 = 634.6 × $0.215 = $136.4
  손실 = $136.4 - $200 = -$63.6 (-32%)
```

### 1일 기대 PnL (보수적 추정)

```
조건: 승률 65%, 건당 $200 베팅, 하루 6건 체결

기대값:
  WIN 4건: 평균 +$50/건 × 4 = +$200
  LOSS 2건: 평균 -$60/건 × 2 = -$120
  ─────────────────────────────
  하루 기대 PnL: +$80 (+1.6% on $5,000)
  월간 추정: +$2,400 (약 48% 월수익, 복리 미적용)
```

⚠️ 단, 이는 **좋은 고래가 발굴된 상태**를 전제로 한 추정치다.
고래 활동이 없거나 오늘 마켓에서 거래하는 고래가 없으면 체결 0건도 가능하다.

---

## 14. 현재 한계 및 리스크

### 구조적 리스크

| 리스크 | 내용 |
|--------|------|
| **진입 지연** | 고래 거래 감지 후 최소 3~10초 후 진입 → 가격 이미 불리하게 이동 |
| **고래 의존성** | 활동하는 좋은 고래가 없으면 수익 없음 |
| **Recursive 마켓** | 5분 마켓은 결과가 빠르지만 변동성도 크다 |
| **슬리피지 과소 추정** | 실제 체결 슬리피지가 모델보다 클 수 있음 |
| **API 의존성** | Polymarket API 다운 시 신호 감지 불가 |

### 페이퍼 트레이딩과 실전의 차이

| 항목 | 페이퍼 | 실전 |
|------|--------|------|
| 체결 | 항상 즉시 체결 가정 | 실제 오더북 유동성 필요 |
| 슬리피지 | 고정% 모델 | 실시간 호가창 기반 |
| 수수료 | 근사치 적용 | 실제 가스비 + 프로토콜 수수료 |
| 정산 | 즉시 가정 | Oracle 업데이트 30~60분 지연 |

---

## 부록: 파일 구조

```
polymarket_trader_bot/
├── whale_copy_bot.py     # 메인 봇 (본 문서의 핵심 로직)
├── whale_manager.py      # 고래 발굴 및 유지관리
├── whale_scorer.py       # 고래 점수 계산
├── client_wrapper.py     # Polymarket API 클라이언트
├── dashboard.py          # 실시간 터미널 대시보드
├── config.py             # 설정 (API 키, 초기 자본 등)
├── whales.json           # 고래 데이터베이스
├── trade_history.jsonl   # 거래 이력 (1건 1줄 JSON)
├── status_WhaleCopy.json # 대시보드용 상태 스냅샷
└── bot_live.log          # 실시간 봇 로그
```

---

*"시장에서 가장 똑똑한 플레이어를 찾아내어 그 위에 올라타라."*
